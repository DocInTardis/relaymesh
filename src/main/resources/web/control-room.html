<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>RelayMesh Control Room</title>
  <style>
    :root {
      --bg: radial-gradient(circle at 10% 10%, #f8fafc 0%, #e2e8f0 45%, #cbd5e1 100%);
      --ink: #0f172a;
      --muted: #475569;
      --line: #94a3b8;
      --panel: rgba(248, 250, 252, 0.95);
      --accent: #0f766e;
      --accent2: #0369a1;
      --warning: #b45309;
      --active: #fef3c7;
      --active-line: #f59e0b;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      color: var(--ink);
      font-family: "Space Grotesk", "Segoe UI", sans-serif;
      background: var(--bg);
    }
    .wrap {
      max-width: 1480px;
      margin: 16px auto 20px;
      padding: 0 14px;
    }
    .topbar {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 8px 20px rgba(2, 6, 23, 0.08);
      margin-bottom: 12px;
    }
    .title {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: baseline;
      margin-bottom: 10px;
    }
    .title h1 {
      margin: 0;
      font-size: 28px;
      letter-spacing: 0.3px;
    }
    .title p {
      margin: 0;
      color: var(--muted);
    }
    .controls {
      display: grid;
      grid-template-columns: repeat(11, minmax(0, 1fr));
      gap: 8px;
    }
    .ops {
      display: grid;
      grid-template-columns: repeat(8, minmax(0, 1fr));
      gap: 8px;
      margin-top: 8px;
    }
    .profiles {
      display: grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap: 8px;
      margin-top: 8px;
    }
    .actions {
      display: grid;
      grid-template-columns: repeat(9, minmax(0, 1fr));
      gap: 8px;
      margin-top: 8px;
    }
    .commandbar {
      display: grid;
      grid-template-columns: 5fr 1fr 1fr;
      gap: 8px;
      margin-top: 8px;
    }
    .hint {
      margin-top: 8px;
      color: var(--muted);
      font-size: 12px;
    }
    input, select, button {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 7px 9px;
      font: inherit;
      color: var(--ink);
      background: #fff;
    }
    button {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
      cursor: pointer;
    }
    .secondary {
      background: #0f172a;
      border-color: #0f172a;
    }
    .warning {
      background: var(--warning);
      border-color: var(--warning);
    }
    .status {
      margin-top: 8px;
      font-family: "IBM Plex Mono", "JetBrains Mono", Consolas, monospace;
      font-size: 12px;
      color: var(--accent2);
    }
    .action-result {
      margin-top: 8px;
      font-family: "IBM Plex Mono", "JetBrains Mono", Consolas, monospace;
      font-size: 12px;
      color: #0f172a;
      border: 1px solid #cbd5e1;
      background: #f8fafc;
      border-radius: 8px;
      padding: 8px;
      max-height: 180px;
      overflow: auto;
      white-space: pre-wrap;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }
    .pane {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 10px;
      min-height: 260px;
      box-shadow: 0 8px 22px rgba(2, 6, 23, 0.08);
    }
    .pane.active {
      border-color: var(--active-line);
      background: var(--active);
      box-shadow: 0 12px 28px rgba(245, 158, 11, 0.25);
    }
    .pane-head {
      display: grid;
      grid-template-columns: 120px 1fr 1fr 90px 1fr;
      gap: 6px;
      align-items: center;
      margin-bottom: 8px;
    }
    .pane-title {
      font-size: 14px;
      font-weight: 700;
    }
    .mono {
      font-family: "IBM Plex Mono", "JetBrains Mono", Consolas, monospace;
      font-size: 12px;
    }
    .pane-body {
      border: 1px solid #cbd5e1;
      border-radius: 10px;
      background: #f8fafc;
      min-height: 192px;
      max-height: 380px;
      overflow: auto;
      padding: 8px;
      white-space: pre;
    }
    @media (max-width: 1200px) {
      .controls {
        grid-template-columns: repeat(6, minmax(0, 1fr));
      }
      .ops {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
      .profiles {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
      .actions {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
      .commandbar {
        grid-template-columns: 1fr;
      }
      .pane-head {
        grid-template-columns: 120px 1fr 1fr;
      }
    }
    @media (max-width: 860px) {
      .grid {
        grid-template-columns: 1fr;
      }
      .controls {
        grid-template-columns: 1fr;
      }
      .ops {
        grid-template-columns: 1fr;
      }
      .profiles {
        grid-template-columns: 1fr;
      }
      .actions {
        grid-template-columns: 1fr;
      }
      .commandbar {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="title">
        <h1>RelayMesh Control Room</h1>
        <p>multi-screen operator view with shared snapshots</p>
      </div>
      <div class="controls">
        <input id="tokenInput" placeholder="token (optional)">
        <input id="namespacesInput" placeholder="namespaces: all or default,project-a">
        <input id="statusFilterInput" placeholder="task status filter (optional)">
        <input id="focusTaskInput" placeholder="focus task id (workflow/actions)">
        <input id="refreshSecInput" type="number" min="1" max="60" value="5" placeholder="refresh sec">
        <select id="transportInput">
          <option value="sse">transport: sse</option>
          <option value="poll">transport: poll</option>
        </select>
        <select id="presetInput">
          <option value="">preset (optional)</option>
          <option value="ops">ops</option>
          <option value="incident">incident</option>
          <option value="throughput">throughput</option>
          <option value="audit">audit</option>
        </select>
        <button onclick="manualRefresh()">Refresh Now</button>
        <button onclick="applySelectedPreset()">Apply Preset</button>
        <button onclick="saveLayoutToStorage()">Save Layout</button>
        <button class="warning" onclick="clearStoredLayout()">Clear Layout</button>
      </div>
      <div class="ops">
        <button class="secondary" onclick="copyShareLink()">Copy Share Link</button>
        <button class="secondary" onclick="window.location.href='/'">Open Classic Console</button>
        <button class="secondary" onclick="window.open('/?token=' + encodeURIComponent(authToken()), '_blank')">Classic In New Tab</button>
        <button class="secondary" onclick="addPane()">Add Pane</button>
        <button class="secondary" onclick="removePane()">Remove Pane</button>
        <button class="secondary" onclick="openApiNamespaces()">Open /api/namespaces</button>
        <button class="secondary" onclick="openApiSnapshot()">Open Snapshot API</button>
        <button class="secondary" onclick="toggleFullscreen()">Toggle Fullscreen</button>
      </div>
      <div class="profiles">
        <input id="profileNameInput" placeholder="layout profile name">
        <select id="profileSelect"><option value="">profile list</option></select>
        <button onclick="saveProfile()">Save Profile</button>
        <button onclick="loadSelectedProfile()">Load Profile</button>
        <button onclick="deleteSelectedProfile()">Delete Profile</button>
        <button class="secondary" onclick="refreshProfiles()">Refresh Profiles</button>
      </div>
      <div class="actions">
        <input id="actionNamespaceInput" placeholder="action namespace (blank = focused pane)">
        <input id="actionTaskIdInput" placeholder="task id (blank = infer from pane)">
        <input id="actionReasonInput" placeholder="reason (optional)">
        <button onclick="runControlAction('cancel','soft')">Soft Cancel</button>
        <button onclick="runControlAction('cancel','hard')">Hard Cancel</button>
        <button onclick="runControlAction('replay')">Replay Task</button>
        <button onclick="runControlAction('replay_batch')">Replay Batch</button>
        <button class="secondary" onclick="clearActionInputs()">Clear Action Inputs</button>
        <button class="secondary" onclick="clearActionResult()">Clear Action Output</button>
      </div>
      <div class="commandbar">
        <input id="commandInput" placeholder="command: stats|members|tasks|workflow|cancel|replay|replay-batch <ns> ... | pane add|remove | preset <name> | refresh">
        <button class="secondary" onclick="runCommandLine()">Run Cmd</button>
        <button class="secondary" onclick="showCommandHelp()">Cmd Help</button>
      </div>
      <div class="hint">
        Hotkeys: Alt+1..9 focus panel, Tab/Shift+Tab cycle, Ctrl+R refresh, Ctrl+S save layout, Ctrl+L copy link, Ctrl++ add pane, Ctrl+- remove pane, Ctrl+Enter run command.
      </div>
      <div id="statusLine" class="status mono">booting...</div>
      <div id="actionResult" class="action-result">action output: ready</div>
    </div>
    <section id="paneGrid" class="grid"></section>
  </div>
  <script>
    const STORAGE_KEY = 'relaymesh.control-room.layout.v2';
    const MAX_PANES = 9;
    const MIN_PANES = 2;
    const PRESETS = {
      ops: [
        { namespace: 'default', view: 'tasks', limit: 20, status: '' },
        { namespace: 'default', view: 'dead', limit: 20, status: '' },
        { namespace: 'default', view: 'conflicts', limit: 20, status: '' },
        { namespace: 'default', view: 'stats', limit: 1, status: '' }
      ],
      incident: [
        { namespace: 'default', view: 'tasks', limit: 30, status: 'RETRYING' },
        { namespace: 'default', view: 'dead', limit: 30, status: '' },
        { namespace: 'default', view: 'conflicts', limit: 30, status: '' },
        { namespace: 'default', view: 'members', limit: 1, status: '' }
      ],
      throughput: [
        { namespace: 'default', view: 'tasks', limit: 40, status: 'RUNNING' },
        { namespace: 'default', view: 'tasks', limit: 40, status: 'SUCCESS' },
        { namespace: 'default', view: 'tasks', limit: 40, status: 'PENDING' },
        { namespace: 'default', view: 'stats', limit: 1, status: '' }
      ],
      audit: [
        { namespace: 'default', view: 'dead', limit: 30, status: '' },
        { namespace: 'default', view: 'conflicts', limit: 30, status: '' },
        { namespace: 'default', view: 'members', limit: 1, status: '' },
        { namespace: 'default', view: 'stats', limit: 1, status: '' }
      ]
    };

    function defaultPanes() {
      return [
        { index: 1, namespace: 'default', view: 'tasks', limit: 12, status: '' },
        { index: 2, namespace: 'default', view: 'dead', limit: 12, status: '' },
        { index: 3, namespace: 'default', view: 'conflicts', limit: 20, status: '' },
        { index: 4, namespace: 'default', view: 'stats', limit: 1, status: '' }
      ];
    }

    const state = {
      namespaces: [],
      snapshot: null,
      workflowCache: {},
      activePane: 0,
      pollTimer: null,
      stream: null,
      persistTimer: null,
      panes: defaultPanes(),
      pendingLayout: null,
      pendingPreset: '',
      pendingProfile: ''
    };

    function authToken() {
      return document.getElementById('tokenInput').value.trim();
    }

    function withAuth(url) {
      const token = authToken();
      if (!token) return url;
      const sep = url.includes('?') ? '&' : '?';
      return url + sep + 'token=' + encodeURIComponent(token);
    }

    async function fetchJson(url) {
      const r = await fetch(withAuth(url));
      if (!r.ok) {
        throw new Error(await r.text());
      }
      return r.json();
    }

    async function postForm(url, params) {
      const body = new URLSearchParams(params).toString();
      const r = await fetch(withAuth(url), {
        method: 'POST',
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
        body
      });
      if (!r.ok) {
        throw new Error(await r.text());
      }
      return r.json();
    }

    function paneCount() {
      return state.panes.length;
    }

    function ensurePaneShape(raw) {
      const views = new Set(['tasks', 'dead', 'conflicts', 'members', 'stats']);
      const source = Array.isArray(raw) ? raw : [];
      const out = [];
      const targetCount = Math.max(MIN_PANES, Math.min(MAX_PANES, source.length > 0 ? source.length : 4));
      for (let i = 0; i < targetCount; i++) {
        const src = source[i] || {};
        const view = typeof src.view === 'string' && views.has(src.view) ? src.view : 'tasks';
        const namespace = typeof src.namespace === 'string' && src.namespace.trim() ? src.namespace.trim() : 'default';
        const status = typeof src.status === 'string' ? src.status.trim() : '';
        const limitRaw = Number.parseInt(String(src.limit || ''), 10);
        const limit = Number.isFinite(limitRaw) ? Math.max(1, Math.min(200, limitRaw)) : 20;
        out.push({
          index: i + 1,
          namespace,
          view,
          limit,
          status
        });
      }
      return out;
    }

    function paneNamespaceOptions(selected) {
      const values = state.namespaces.length > 0 ? state.namespaces : ['default'];
      return values.map(ns => {
        const sel = ns === selected ? 'selected' : '';
        return `<option value="${ns}" ${sel}>${ns}</option>`;
      }).join('');
    }

    function paneViewOptions(selected) {
      const views = ['tasks', 'dead', 'conflicts', 'members', 'stats', 'workflow'];
      return views.map(v => {
        const sel = v === selected ? 'selected' : '';
        return `<option value="${v}" ${sel}>${v}</option>`;
      }).join('');
    }

    function reconcilePaneNamespaces() {
      const fallback = state.namespaces.length > 0 ? state.namespaces[0] : 'default';
      for (const pane of state.panes) {
        if (!state.namespaces.includes(pane.namespace)) {
          pane.namespace = fallback;
        }
      }
    }

    function renderPaneShells() {
      const grid = document.getElementById('paneGrid');
      grid.innerHTML = '';
      for (const cfg of state.panes) {
        const pane = document.createElement('article');
        pane.className = 'pane';
        pane.dataset.index = String(cfg.index - 1);
        pane.innerHTML = `
          <div class="pane-head">
            <div class="pane-title">Pane ${cfg.index} (Alt+${cfg.index})</div>
            <select class="nsSelect">${paneNamespaceOptions(cfg.namespace)}</select>
            <select class="viewSelect">${paneViewOptions(cfg.view)}</select>
            <input class="limitInput" type="number" min="1" max="200" value="${cfg.limit}">
            <input class="statusInput" placeholder="status filter (tasks only)" value="${cfg.status}">
          </div>
          <div class="pane-body mono" id="paneBody${cfg.index}">loading...</div>
        `;
        grid.appendChild(pane);
      }
      bindPaneControls();
      focusPane(state.activePane);
    }

    function bindPaneControls() {
      const panes = document.querySelectorAll('.pane');
      panes.forEach((pane, idx) => {
        pane.addEventListener('click', () => focusPane(idx));
        const nsSel = pane.querySelector('.nsSelect');
        const viewSel = pane.querySelector('.viewSelect');
        const limitInput = pane.querySelector('.limitInput');
        const statusInput = pane.querySelector('.statusInput');
        nsSel.addEventListener('change', () => {
          state.panes[idx].namespace = nsSel.value;
          renderPaneData(idx);
          persistLayoutSoon();
        });
        viewSel.addEventListener('change', () => {
          state.panes[idx].view = viewSel.value;
          renderPaneData(idx);
          persistLayoutSoon();
        });
        limitInput.addEventListener('change', () => {
          const next = Number.parseInt(limitInput.value, 10);
          state.panes[idx].limit = Number.isFinite(next) ? Math.max(1, Math.min(200, next)) : 20;
          limitInput.value = String(state.panes[idx].limit);
          renderPaneData(idx);
          persistLayoutSoon();
        });
        statusInput.addEventListener('change', () => {
          state.panes[idx].status = statusInput.value.trim();
          renderPaneData(idx);
          persistLayoutSoon();
        });
      });
    }

    function focusPane(index) {
      const panes = document.querySelectorAll('.pane');
      if (panes.length === 0) return;
      const normalized = (index + panes.length) % panes.length;
      state.activePane = normalized;
      panes.forEach((pane, idx) => {
        if (idx === normalized) pane.classList.add('active');
        else pane.classList.remove('active');
      });
      persistLayoutSoon();
    }

    function activePaneConfig() {
      if (state.panes.length === 0) return null;
      const idx = Math.max(0, Math.min(state.panes.length - 1, state.activePane));
      return state.panes[idx] || null;
    }

    function selectedNamespacesQuery() {
      const raw = document.getElementById('namespacesInput').value.trim();
      if (!raw) return 'all';
      return raw;
    }

    function globalStatusFilter() {
      return document.getElementById('statusFilterInput').value.trim();
    }

    function maxPaneLimit(view) {
      let max = 20;
      for (const pane of state.panes) {
        if (view === 'task' && pane.view === 'tasks') {
          max = Math.max(max, pane.limit || 20);
        }
        if (view === 'dead' && pane.view === 'dead') {
          max = Math.max(max, pane.limit || 20);
        }
        if (view === 'conflicts' && pane.view === 'conflicts') {
          max = Math.max(max, pane.limit || 20);
        }
      }
      return Math.max(1, Math.min(200, max));
    }

    async function loadNamespaces() {
      const body = await fetchJson('/api/namespaces');
      state.namespaces = body.namespaces || [];
      const active = body.activeNamespace || 'default';
      if (!state.namespaces.includes(active)) {
        state.namespaces.unshift(active);
      }
      if (!document.getElementById('namespacesInput').value.trim()) {
        document.getElementById('namespacesInput').value = state.namespaces.join(',');
      }
      reconcilePaneNamespaces();
      renderPaneShells();
    }

    function setStatusLine(msg) {
      document.getElementById('statusLine').textContent = msg;
    }

    function maxPollIntervalSec() {
      const secRaw = Number.parseInt(document.getElementById('refreshSecInput').value, 10);
      const sec = Number.isFinite(secRaw) ? Math.max(1, Math.min(60, secRaw)) : 5;
      document.getElementById('refreshSecInput').value = String(sec);
      return sec;
    }

    function buildSnapshotParams(includeInterval) {
      const qp = new URLSearchParams();
      qp.set('namespaces', selectedNamespacesQuery());
      qp.set('taskLimit', String(maxPaneLimit('task')));
      qp.set('deadLimit', String(maxPaneLimit('dead')));
      qp.set('conflictLimit', String(maxPaneLimit('conflicts')));
      const status = globalStatusFilter();
      if (status) qp.set('status', status);
      if (includeInterval) {
        qp.set('intervalMs', String(maxPollIntervalSec() * 1000));
      }
      return qp;
    }

    function updateSnapshot(body, source) {
      state.snapshot = body;
      renderAllPaneData();
      const names = (body.requestedNamespaces || []).join(',');
      const ts = body.timestamp || new Date().toISOString();
      setStatusLine(source + ' ok @ ' + ts + ' namespaces=' + names + ' mode=' + currentTransport());
    }

    async function loadSnapshot() {
      const qp = buildSnapshotParams(false);
      const body = await fetchJson('/api/control-room/snapshot?' + qp.toString());
      updateSnapshot(body, 'snapshot');
    }

    function safeArray(value) {
      return Array.isArray(value) ? value : [];
    }

    function truncateLines(lines, limit) {
      if (lines.length <= limit) return lines;
      const copy = lines.slice(0, limit);
      copy.push('... (' + (lines.length - limit) + ' more)');
      return copy;
    }

    function workflowCacheKey(namespace, taskId) {
      return namespace + '::' + taskId;
    }

    function firstTaskIdForNamespace(slot) {
      const tasks = safeArray(slot.tasks);
      if (tasks.length > 0 && tasks[0] && tasks[0].taskId) {
        return String(tasks[0].taskId);
      }
      const dead = safeArray(slot.dead);
      if (dead.length > 0 && dead[0] && dead[0].taskId) {
        return String(dead[0].taskId);
      }
      return '';
    }

    function formatWorkflowPayload(payload, namespace, taskId) {
      const wf = payload && payload.workflow ? payload.workflow : {};
      const task = wf && wf.task ? wf.task : {};
      const status = task && task.status ? String(task.status) : '';
      const edges = Array.isArray(payload && payload.edges) ? payload.edges : [];
      const head = 'workflow namespace=' + namespace + ' task=' + taskId + ' status=' + status;
      if (edges.length === 0) {
        return head + '\\n\\n(no edges)';
      }
      return head + '\\n\\n' + edges.join('\\n');
    }

    async function loadWorkflowForPane(index, namespace, taskId) {
      const key = workflowCacheKey(namespace, taskId);
      try {
        let payload = state.workflowCache[key];
        if (!payload) {
          payload = await fetchJson('/api/control-room/workflow?namespace=' + encodeURIComponent(namespace) + '&taskId=' + encodeURIComponent(taskId));
          state.workflowCache[key] = payload;
        }
        const pane = state.panes[index];
        if (!pane || pane.namespace !== namespace || pane.view !== 'workflow') {
          return;
        }
        const body = document.getElementById('paneBody' + pane.index);
        if (!body) return;
        body.textContent = formatWorkflowPayload(payload, namespace, taskId);
      } catch (e) {
        const pane = state.panes[index];
        if (!pane || pane.namespace !== namespace || pane.view !== 'workflow') {
          return;
        }
        const body = document.getElementById('paneBody' + pane.index);
        if (!body) return;
        body.textContent = 'workflow load failed: ' + e.message;
      }
    }

    function renderPaneData(index) {
      const cfg = state.panes[index];
      const body = document.getElementById('paneBody' + cfg.index);
      if (!body) return;
      if (!state.snapshot || !state.snapshot.data) {
        body.textContent = 'waiting for snapshot...';
        return;
      }
      const ns = cfg.namespace;
      const slot = state.snapshot.data[ns];
      if (!slot) {
        body.textContent = 'namespace not found in snapshot: ' + ns;
        return;
      }
      const view = cfg.view;
      if (view === 'tasks') {
        let rows = safeArray(slot.tasks);
        const localStatus = cfg.status || globalStatusFilter();
        if (localStatus) {
          rows = rows.filter(t => String(t.status || '').toUpperCase() === localStatus.toUpperCase());
        }
        const lines = rows.map(t => `${t.taskId} | ${t.status} | ${t.updatedAtMs}`);
        body.textContent = truncateLines(lines, cfg.limit).join('\\n') || '(empty tasks)';
        return;
      }
      if (view === 'dead') {
        const rows = safeArray(slot.dead);
        const lines = rows.map(t => `${t.taskId} | ${t.status} | ${t.lastError || ''}`);
        body.textContent = truncateLines(lines, cfg.limit).join('\\n') || '(empty dead)';
        return;
      }
      if (view === 'conflicts') {
        const rows = safeArray(slot.conflicts);
        const lines = rows.map(c => `${c.type || 'conflict'} | step=${c.stepId || ''} | task=${c.taskId || ''} | at=${c.occurredAtMs || ''}`);
        body.textContent = truncateLines(lines, cfg.limit).join('\\n') || '(empty conflicts)';
        return;
      }
      if (view === 'members') {
        body.textContent = JSON.stringify(slot.members || {}, null, 2);
        return;
      }
      if (view === 'workflow') {
        const taskId = focusTaskId() || firstTaskIdForNamespace(slot);
        if (!taskId) {
          body.textContent = 'workflow view: set focus task id, or keep tasks available in this namespace';
          return;
        }
        const key = workflowCacheKey(ns, taskId);
        const cached = state.workflowCache[key];
        if (cached) {
          body.textContent = formatWorkflowPayload(cached, ns, taskId);
          return;
        }
        body.textContent = 'loading workflow for task=' + taskId + ' ...';
        loadWorkflowForPane(index, ns, taskId);
        return;
      }
      body.textContent = JSON.stringify(slot.stats || {}, null, 2);
    }

    function renderAllPaneData() {
      for (let i = 0; i < state.panes.length; i++) {
        renderPaneData(i);
      }
    }

    function setActionResult(text) {
      document.getElementById('actionResult').textContent = text;
    }

    function clearActionResult() {
      setActionResult('action output: cleared');
    }

    function clearActionInputs() {
      document.getElementById('actionNamespaceInput').value = '';
      document.getElementById('actionTaskIdInput').value = '';
      document.getElementById('actionReasonInput').value = '';
    }

    function inferTaskIdFromActivePane() {
      if (!state.snapshot || !state.snapshot.data) return '';
      const active = activePaneConfig();
      if (!active) return '';
      const slot = state.snapshot.data[active.namespace];
      if (!slot) return '';
      const rows = active.view === 'dead' ? safeArray(slot.dead) : safeArray(slot.tasks);
      if (rows.length === 0) return '';
      const first = rows[0];
      return first && first.taskId ? String(first.taskId) : '';
    }

    function focusTaskId() {
      return document.getElementById('focusTaskInput').value.trim();
    }

    function actionNamespace() {
      const raw = document.getElementById('actionNamespaceInput').value.trim();
      if (raw) return raw;
      const active = activePaneConfig();
      if (active && active.namespace) return active.namespace;
      return 'default';
    }

    function actionTaskId() {
      const raw = document.getElementById('actionTaskIdInput').value.trim();
      if (raw) return raw;
      const focus = focusTaskId();
      if (focus) return focus;
      return inferTaskIdFromActivePane();
    }

    async function runControlAction(action, mode = '') {
      const namespace = actionNamespace();
      const reason = document.getElementById('actionReasonInput').value.trim();
      const payload = { action, namespace };
      if (mode) payload.mode = mode;
      if (reason) payload.reason = reason;
      if (action === 'cancel' || action === 'replay') {
        const taskId = actionTaskId();
        if (!taskId) {
          setActionResult('action failed: missing task id');
          return;
        }
        payload.taskId = taskId;
      }
      if (action === 'replay_batch') {
        payload.status = 'DEAD_LETTER';
        payload.limit = '50';
      }
      try {
        const out = await postForm('/api/control-room/action', payload);
        setActionResult(JSON.stringify(out, null, 2));
        state.workflowCache = {};
        await loadSnapshot();
      } catch (e) {
        setActionResult('action failed: ' + e.message);
      }
    }

    function tokenizeCommand(raw) {
      if (!raw) return [];
      return raw.trim().split(/\s+/).filter(Boolean);
    }

    async function runCommandLine() {
      const raw = document.getElementById('commandInput').value.trim();
      if (!raw) return;
      const parts = tokenizeCommand(raw);
      if (parts.length === 0) return;
      const cmd = parts[0].toLowerCase();
      try {
        if (cmd === 'refresh') {
          await loadSnapshot();
          return;
        }
        if (cmd === 'preset' && parts.length >= 2) {
          const name = parts[1].toLowerCase();
          document.getElementById('presetInput').value = name;
          applyPreset(name);
          await loadSnapshot();
          return;
        }
        if (cmd === 'pane' && parts.length >= 2) {
          const op = parts[1].toLowerCase();
          if (op === 'add') {
            addPane();
            return;
          }
          if (op === 'remove') {
            removePane();
            return;
          }
        }
        if (cmd === 'profile' && parts.length >= 2) {
          const op = parts[1].toLowerCase();
          if (op === 'list') {
            await refreshProfiles();
            return;
          }
          if (op === 'save' && parts.length >= 3) {
            document.getElementById('profileNameInput').value = parts[2];
            await saveProfile();
            return;
          }
          if (op === 'load' && parts.length >= 3) {
            await loadProfileByName(parts[2]);
            return;
          }
          if (op === 'delete' && parts.length >= 3) {
            document.getElementById('profileNameInput').value = parts[2];
            await deleteSelectedProfile();
            return;
          }
        }
        const out = await postForm('/api/control-room/command', { command: raw });
        setActionResult(JSON.stringify(out, null, 2));
        const lower = cmd.toLowerCase();
        if (lower === 'cancel' || lower === 'replay' || lower === 'replay-batch' || lower === 'replay_batch') {
          state.workflowCache = {};
        }
        if (lower === 'workflow' && parts.length >= 3) {
          document.getElementById('focusTaskInput').value = parts[2];
        }
        if (lower === 'help') {
          return;
        }
        await loadSnapshot();
      } catch (e) {
        setActionResult('command failed: ' + e.message);
      }
    }

    function showCommandHelp() {
      const lines = [
        'commands:',
        'refresh',
        'preset <ops|incident|throughput|audit>',
        'pane add',
        'pane remove',
        'profile list',
        'profile save <name>',
        'profile load <name>',
        'profile delete <name>',
        'namespaces',
        'stats <namespace>',
        'members <namespace>',
        'tasks <namespace> [status] [limit]',
        'workflow <namespace> <taskId>',
        'cancel <namespace> <taskId> [soft|hard] [reason...]',
        'replay <namespace> <taskId>',
        'replay-batch <namespace> [limit]'
      ];
      setActionResult(lines.join('\\n'));
    }

    function manualRefresh() {
      loadSnapshot().catch(err => {
        setStatusLine('snapshot failed: ' + err.message);
      });
    }

    function stopRealtime() {
      if (state.pollTimer) {
        clearInterval(state.pollTimer);
        state.pollTimer = null;
      }
      if (state.stream) {
        state.stream.close();
        state.stream = null;
      }
    }

    function rearmPolling() {
      stopRealtime();
      const sec = maxPollIntervalSec();
      state.pollTimer = setInterval(() => {
        loadSnapshot().catch(err => {
          setStatusLine('snapshot failed: ' + err.message);
        });
      }, sec * 1000);
    }

    function connectControlStream() {
      stopRealtime();
      const params = buildSnapshotParams(true);
      const es = new EventSource(withAuth('/events/control-room?' + params.toString()));
      state.stream = es;
      es.onopen = () => {
        setStatusLine('stream connected');
      };
      es.onerror = () => {
        setStatusLine('stream reconnecting...');
      };
      es.addEventListener('control_snapshot', ev => {
        try {
          const payload = JSON.parse(ev.data);
          updateSnapshot(payload, 'stream');
        } catch (e) {
          setStatusLine('stream parse failed: ' + e.message);
        }
      });
    }

    function currentTransport() {
      const value = document.getElementById('transportInput').value;
      return value === 'poll' ? 'poll' : 'sse';
    }

    function applyTransport() {
      if (currentTransport() === 'poll') {
        rearmPolling();
        return;
      }
      connectControlStream();
    }

    function exportLayoutState() {
      return {
        panes: state.panes.map(p => ({
          namespace: p.namespace,
          view: p.view,
          limit: p.limit,
          status: p.status || ''
        })),
        namespaces: document.getElementById('namespacesInput').value.trim(),
        statusFilter: document.getElementById('statusFilterInput').value.trim(),
        focusTaskId: document.getElementById('focusTaskInput').value.trim(),
        actionNs: document.getElementById('actionNamespaceInput').value.trim(),
        profile: document.getElementById('profileNameInput').value.trim(),
        refreshSec: maxPollIntervalSec(),
        transport: currentTransport(),
        preset: document.getElementById('presetInput').value || '',
        activePane: state.activePane
      };
    }

    function applyLayout(layout) {
      if (!layout || typeof layout !== 'object') return;
      if (typeof layout.namespaces === 'string') {
        document.getElementById('namespacesInput').value = layout.namespaces;
      }
      if (typeof layout.statusFilter === 'string') {
        document.getElementById('statusFilterInput').value = layout.statusFilter;
      }
      if (typeof layout.focusTaskId === 'string') {
        document.getElementById('focusTaskInput').value = layout.focusTaskId;
      }
      if (typeof layout.actionNs === 'string') {
        document.getElementById('actionNamespaceInput').value = layout.actionNs;
      }
      if (typeof layout.profile === 'string') {
        document.getElementById('profileNameInput').value = layout.profile;
      }
      if (layout.refreshSec != null) {
        document.getElementById('refreshSecInput').value = String(layout.refreshSec);
      }
      if (layout.transport === 'poll' || layout.transport === 'sse') {
        document.getElementById('transportInput').value = layout.transport;
      }
      if (typeof layout.preset === 'string') {
        document.getElementById('presetInput').value = layout.preset;
      }
      state.panes = ensurePaneShape(layout.panes);
      state.activePane = Number.isFinite(layout.activePane) ? Math.max(0, Math.min(paneCount() - 1, layout.activePane)) : 0;
    }

    function saveLayoutToStorage() {
      try {
        const payload = exportLayoutState();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
        setStatusLine('layout saved');
      } catch (e) {
        setStatusLine('save layout failed: ' + e.message);
      }
    }

    function persistLayoutSoon() {
      if (state.persistTimer) {
        clearTimeout(state.persistTimer);
      }
      state.persistTimer = setTimeout(() => {
        saveLayoutToStorage();
        state.persistTimer = null;
      }, 350);
    }

    function loadLayoutFromStorage() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch (e) {
        return null;
      }
    }

    function clearStoredLayout() {
      try {
        localStorage.removeItem(STORAGE_KEY);
        setStatusLine('stored layout cleared');
      } catch (e) {
        setStatusLine('clear layout failed: ' + e.message);
      }
    }

    function applyPreset(name) {
      const preset = PRESETS[name];
      if (!preset) return;
      const fallbackNs = state.namespaces.length > 0 ? state.namespaces[0] : 'default';
      const hydrated = preset.map((pane, idx) => ({
        index: idx + 1,
        namespace: state.namespaces.includes(pane.namespace) ? pane.namespace : fallbackNs,
        view: pane.view,
        limit: pane.limit,
        status: pane.status || ''
      }));
      state.panes = ensurePaneShape(hydrated);
      renderPaneShells();
      renderAllPaneData();
      persistLayoutSoon();
    }

    function applySelectedPreset() {
      const name = document.getElementById('presetInput').value;
      if (!name) return;
      applyPreset(name);
      manualRefresh();
    }

    function copyShareLink() {
      const qp = new URLSearchParams();
      qp.set('layout', JSON.stringify(exportLayoutState()));
      const link = window.location.origin + window.location.pathname + '?' + qp.toString();
      navigator.clipboard.writeText(link)
        .then(() => setStatusLine('share link copied'))
        .catch(err => setStatusLine('copy link failed: ' + err.message));
    }

    function profileNameFromInputs() {
      const rawInput = document.getElementById('profileNameInput').value.trim();
      if (rawInput) return rawInput;
      const selected = document.getElementById('profileSelect').value.trim();
      return selected;
    }

    async function refreshProfiles() {
      try {
        const out = await fetchJson('/api/control-room/layouts');
        const profiles = Array.isArray(out.profiles) ? out.profiles : [];
        const select = document.getElementById('profileSelect');
        const current = select.value;
        select.innerHTML = '<option value=\"\">profile list</option>';
        for (const name of profiles) {
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name;
          select.appendChild(opt);
        }
        if (current && profiles.includes(current)) {
          select.value = current;
        }
        setStatusLine('profiles loaded: ' + profiles.length);
      } catch (e) {
        setStatusLine('profile load failed: ' + e.message);
      }
    }

    async function saveProfile() {
      const name = profileNameFromInputs();
      if (!name) {
        setActionResult('profile save failed: missing profile name');
        return;
      }
      try {
        const payload = {
          name,
          layout: JSON.stringify(exportLayoutState())
        };
        const out = await postForm('/api/control-room/layouts/save', payload);
        document.getElementById('profileNameInput').value = name;
        await refreshProfiles();
        document.getElementById('profileSelect').value = name;
        setActionResult(JSON.stringify(out, null, 2));
      } catch (e) {
        setActionResult('profile save failed: ' + e.message);
      }
    }

    async function loadProfileByName(name) {
      if (!name) {
        setActionResult('profile load failed: missing profile name');
        return;
      }
      try {
        const out = await fetchJson('/api/control-room/layouts?name=' + encodeURIComponent(name));
        applyLayout(out.layout || {});
        reconcilePaneNamespaces();
        renderPaneShells();
        await loadSnapshot();
        applyTransport();
        document.getElementById('profileNameInput').value = name;
        document.getElementById('profileSelect').value = name;
        setActionResult(JSON.stringify(out, null, 2));
      } catch (e) {
        setActionResult('profile load failed: ' + e.message);
      }
    }

    async function loadSelectedProfile() {
      const name = profileNameFromInputs();
      await loadProfileByName(name);
    }

    async function deleteSelectedProfile() {
      const name = profileNameFromInputs();
      if (!name) {
        setActionResult('profile delete failed: missing profile name');
        return;
      }
      try {
        const out = await postForm('/api/control-room/layouts/delete', { name });
        await refreshProfiles();
        if (document.getElementById('profileSelect').value === name) {
          document.getElementById('profileSelect').value = '';
        }
        setActionResult(JSON.stringify(out, null, 2));
      } catch (e) {
        setActionResult('profile delete failed: ' + e.message);
      }
    }

    function openApiNamespaces() {
      window.open(withAuth('/api/namespaces'), '_blank');
    }

    function openApiSnapshot() {
      const qp = buildSnapshotParams(false);
      window.open(withAuth('/api/control-room/snapshot?' + qp.toString()), '_blank');
    }

    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(() => {});
        return;
      }
      document.exitFullscreen().catch(() => {});
    }

    function addPane() {
      if (state.panes.length >= MAX_PANES) {
        setStatusLine('max panes reached');
        return;
      }
      const fallbackNs = state.namespaces.length > 0 ? state.namespaces[0] : 'default';
      state.panes.push({
        index: state.panes.length + 1,
        namespace: fallbackNs,
        view: 'tasks',
        limit: 12,
        status: ''
      });
      for (let i = 0; i < state.panes.length; i++) {
        state.panes[i].index = i + 1;
      }
      renderPaneShells();
      renderAllPaneData();
      persistLayoutSoon();
    }

    function removePane() {
      if (state.panes.length <= MIN_PANES) {
        setStatusLine('min panes reached');
        return;
      }
      state.panes.pop();
      for (let i = 0; i < state.panes.length; i++) {
        state.panes[i].index = i + 1;
      }
      state.activePane = Math.min(state.activePane, state.panes.length - 1);
      renderPaneShells();
      renderAllPaneData();
      persistLayoutSoon();
    }

    function bindGlobalKeys() {
      document.addEventListener('keydown', ev => {
        if (ev.altKey && !ev.ctrlKey && !ev.shiftKey) {
          const num = Number.parseInt(ev.key, 10);
          if (Number.isFinite(num) && num >= 1 && num <= state.panes.length) {
            ev.preventDefault();
            focusPane(num - 1);
            return;
          }
        }
        if (ev.key === 'Tab') {
          ev.preventDefault();
          const direction = ev.shiftKey ? -1 : 1;
          focusPane(state.activePane + direction);
          return;
        }
        if (ev.ctrlKey && (ev.key === 'r' || ev.key === 'R')) {
          ev.preventDefault();
          manualRefresh();
          return;
        }
        if (ev.ctrlKey && (ev.key === 's' || ev.key === 'S')) {
          ev.preventDefault();
          saveLayoutToStorage();
          return;
        }
        if (ev.ctrlKey && (ev.key === 'l' || ev.key === 'L')) {
          ev.preventDefault();
          copyShareLink();
          return;
        }
        if (ev.ctrlKey && (ev.key === '=' || ev.key === '+')) {
          ev.preventDefault();
          addPane();
          return;
        }
        if (ev.ctrlKey && ev.key === '-') {
          ev.preventDefault();
          removePane();
          return;
        }
        if (ev.ctrlKey && ev.key === 'Enter') {
          ev.preventDefault();
          runCommandLine();
        }
      });
    }

    function initFromQuery() {
      const qp = new URLSearchParams(window.location.search);
      const token = qp.get('token') || '';
      if (token) {
        document.getElementById('tokenInput').value = token;
      }
      const namespaces = qp.get('namespaces') || '';
      if (namespaces) {
        document.getElementById('namespacesInput').value = namespaces;
      }
      const transport = qp.get('transport') || '';
      if (transport === 'poll' || transport === 'sse') {
        document.getElementById('transportInput').value = transport;
      }
      const refreshSec = qp.get('refreshSec') || '';
      if (refreshSec) {
        document.getElementById('refreshSecInput').value = refreshSec;
      }
      const preset = qp.get('preset') || '';
      if (preset) {
        state.pendingPreset = preset;
        document.getElementById('presetInput').value = preset;
      }
      const profile = qp.get('profile') || '';
      if (profile) {
        state.pendingProfile = profile;
        document.getElementById('profileNameInput').value = profile;
      }
      const focusTask = qp.get('focusTask') || '';
      if (focusTask) {
        document.getElementById('focusTaskInput').value = focusTask;
      }
      const actionNs = qp.get('actionNs') || '';
      if (actionNs) {
        document.getElementById('actionNamespaceInput').value = actionNs;
      }
      const layout = qp.get('layout') || '';
      if (layout) {
        try {
          state.pendingLayout = JSON.parse(layout);
        } catch (e) {
          setStatusLine('query layout parse failed');
        }
      }
    }

    function bindTopControls() {
      const triggerRefresh = () => {
        persistLayoutSoon();
        manualRefresh();
        applyTransport();
      };
      document.getElementById('namespacesInput').addEventListener('change', triggerRefresh);
      document.getElementById('statusFilterInput').addEventListener('change', triggerRefresh);
      document.getElementById('focusTaskInput').addEventListener('change', () => {
        persistLayoutSoon();
        renderAllPaneData();
      });
      document.getElementById('refreshSecInput').addEventListener('change', triggerRefresh);
      document.getElementById('transportInput').addEventListener('change', triggerRefresh);
      document.getElementById('presetInput').addEventListener('change', persistLayoutSoon);
      document.getElementById('profileNameInput').addEventListener('change', persistLayoutSoon);
      document.getElementById('profileSelect').addEventListener('change', () => {
        const value = document.getElementById('profileSelect').value.trim();
        if (value) {
          document.getElementById('profileNameInput').value = value;
        }
        persistLayoutSoon();
      });
      document.getElementById('actionNamespaceInput').addEventListener('change', persistLayoutSoon);
      document.getElementById('commandInput').addEventListener('keydown', ev => {
        if (ev.key === 'Enter') {
          ev.preventDefault();
          runCommandLine();
        }
      });
    }

    async function bootstrap() {
      initFromQuery();
      bindGlobalKeys();
      bindTopControls();
      clearActionResult();
      document.getElementById('tokenInput').addEventListener('change', () => {
        stopRealtime();
        loadNamespaces()
          .then(refreshProfiles)
          .then(() => {
            renderPaneShells();
            return loadSnapshot();
          })
          .then(applyTransport)
          .catch(err => setStatusLine('reload failed: ' + err.message));
      });
      await loadNamespaces();
      await refreshProfiles();
      if (state.pendingProfile) {
        await loadProfileByName(state.pendingProfile);
        return;
      }
      const stored = state.pendingLayout == null ? loadLayoutFromStorage() : null;
      if (state.pendingLayout != null) {
        applyLayout(state.pendingLayout);
      } else if (stored) {
        applyLayout(stored);
      } else {
        state.panes = ensurePaneShape(state.panes);
      }
      if (state.pendingPreset) {
        applyPreset(state.pendingPreset);
      }
      reconcilePaneNamespaces();
      renderPaneShells();
      await loadSnapshot();
      applyTransport();
    }

    bootstrap().catch(err => {
      setStatusLine('bootstrap failed: ' + err.message);
    });
  </script>
</body>
</html>
